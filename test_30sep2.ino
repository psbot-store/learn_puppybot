#include <puppybot.h> //คำสั่ง #include <puppybot.h> ใช้ใน Arduino เพื่อเรียกใช้ไฟล์หรือไลบรารีที่ชื่อว่า "puppybot.h"
//เป็นไฟล์หรือไลบรารีที่มีโค้ดหรือคำสั่งเฉพาะสำหรับโปรเจคหรือการใช้งานที่เกี่ยวข้องกับหุ่นยนต์หรือระบบอื่น ๆ ที่เรียกว่า "puppybot
uint8_t totalsensor = 5;
uint16_t connected_port[] = { 0, 1, 2, 3, 4 };
uint16_t min_sensor_ref[] = { 200, 200, 200, 200, 200 };
uint16_t max_sensor_ref[] = { 900, 900, 900, 900, 900 };
uint16_t state_on_Line = 0;
float Kp = 1; //ปรับจูนค่า kp ki kd ที่นี่
float Ki = 0;
float Kd = 0;
uint16_t setpoint;
uint32_t lastPoint;
float error = 0;
float outputpid = 0;
float P;
float I;
float D;
float lastError;
/* *********************************************************************************************************** */
int Servo_degreeA1 = 50;   //ตัวแปรเก็บค่าองศาใน function catch_the_can
int Servo_degreeA2 = 50;   //ตัวแปรเก็บค่าองศาใน function release_can
int Servo_degreeB1 = 160;  //ตัวแปรเก็บค่าองศาใน function put_hand_up
int Servo_degreeB2 = 60;   //ตัวแปรเก็บค่าองศาใน function put_hand_down
int reff[] = { 512, 512, 512, 512, 512 };   //ประกาศตัวแปรเพื่อเก็บค่า reference ใช้เปรียบเทียบ ขาว และ ดำ
/* *********************************************************************************************************** */
int readposition() { //ฟังก์ชันนี้มีหน้าที่อ่านค่าตำแหน่งปัจจุบันของหุ่นยนต์โดยใช้ข้อมูลจากเซ็นเซอร์หรือเซ็นเซอร์สายไลน์ที่ติดตั้งอยู่บนหุ่นยนต์
  bool onLine = false;//กำหนดตัวแปร onLine เป็น false เพื่อตรวจสอบว่าหุ่นยนต์อยู่บนเส้นหรือไม่
  long avg = 0; //กำหนดตัวแปร avg และ sum สำหรับการคำนวณค่าเฉลี่ยของตำแหน่งเซ็นเซอร์ที่ตรวจจับเส้นทาง
  long sum = 0;
  for (uint8_t i = 0; i < totalsensor; i++) { //ใช้ลูปเพื่อสำรวจข้อมูลจากเซ็นเซอร์ทุกตัว.
    long value = map(ADC(connected_port[i]), min_sensor_ref[i], max_sensor_ref[i], 1000, 0);
    //อ่านค่าอนาล็อกแปลงค่าแอนะล็อกดิจิทัล (ADC) จากเซ็นเซอร์ที่ติดตั้งที่ connected_port[i] 
    //แล้วทำการแปลงค่าดิจิทัลเหล่านั้นโดยใช้ map() เพื่อให้ค่าอยู่ในช่วง 0 ถึง 1000 โดยใช้ค่าอ้างอิง min_sensor_ref[i] และ max_sensor_ref[i].
    if (value > 200) { //ตรวจสอบว่าค่าที่ได้จากเซ็นเซอร์มากกว่า 200 หรือไม่ ถ้าใช่ onLine จะถูกตั้งค่าเป็น true ซึ่งหมายถึงหุ่นยนต์อยู่บนเส้นทาง
      onLine = true;
    }
    if (value > 50) { //คำนวณค่าเฉลี่ยของตำแหน่งเซ็นเซอร์ที่ตรวจจับเส้นทางโดยใช้ค่า value 
    //และนำไปบวกกับ avg และเพิ่มค่า value ลงใน sum เฉพาะเซ็นเซอร์ที่มีค่า value มากกว่า 50
      avg += (long)value * (i * 1000);
      sum += value;
    }
  }
  if (!onLine) { //ในกรณีที่หุ่นยนต์ไม่อยู่บนเส้นทาง (!onLine), จะมีการตรวจสอบค่า lastPoint เพื่อกำหนดค่าคืน:
    if (lastPoint < (totalsensor - 1) * 1000 / 2) {
      //ถ้าค่า lastPoint น้อยกว่าครึ่งหนึ่งของระยะทางรวมระหว่างเซ็นเซอร์ ((totalsensor - 1) * 1000 / 2) จะคืนค่า 0 หมายถึงหุ่นยนต์อยู่ทางซ้ายของเส้นทาง
      return 0; 
    } else {
      //ถ้าไม่ใช่ จะคืนค่าเป็นครึ่งหนึ่งของระยะทางรวมระหว่างเซ็นเซอร์ ((totalsensor - 1) * 1000) หมายถึงหุ่นยนต์อยู่ทางขวาของเส้นทาง
      return (totalsensor - 1) * 1000;
    }
  }
  lastPoint = avg / sum; //คำนวณค่าเฉลี่ยของตำแหน่งของเซ็นเซอร์ (lastPoint) โดยหารผลรวม avg ด้วยผลรวม sum
  return lastPoint; //คืนค่า lastPoint ซึ่งเป็นค่าความตำแหน่งปัจจุบันของหุ่นยนต์ที่คำนวณขึ้นมาจากข้อมูลของเซ็นเซอร์
}
/* *********************************************************************************************************** */
void pidcontrolmotor() { //นี่คือฟังก์ชันสำหรับควบคุมมอเตอร์โดยใช้ค่าความผิดพลาดที่คำนวณจาก PID controller
  float motorspeed = 0; //กำหนดความเร็วของมอเตอร์เป็น 0-100 (ค่านี้สามารถปรับเปลี่ยนได้ตามความต้องการ)
  uint16_t position = readposition() / ((totalsensor - 1) * 10);
  //uint16_t position = readposition() / ((totalsensor - 1) * 10);: อ่านค่าตำแหน่งปัจจุบันจากฟังก์ชัน readposition() 
  //และปรับหน่วยให้อยู่ในรูปแบบที่ถูกต้อง โดยหารด้วย (totalsensor - 1) * 10) (เป็นสูตรการคำนวณที่มาจากจำนวนเซ็นเซอร์)
  setpoint = 50.0; //กำหนดค่าเป้าหมาย (setpoint) เป็น 50.0 (ค่านี้สามารถปรับเปลี่ยนได้ตามความต้องการ)
  error = setpoint - position; //คำนวณค่าความผิดพลาด (error) โดยหักค่าตำแหน่งปัจจุบัน (position) จากค่าเป้าหมาย (setpoint)
  if (error == 0) I = 0; //ตรวจสอบว่าความผิดพลาดเป็นศูนย์หรือไม่ ถ้าใช่ จะรีเซ็ตค่าความสะสมของความผิดพลาด (I) เป็นศูนย์
  P = error; //กำหนดค่าส่วนสัมประสิทธิ์ (P) เป็นค่าความผิดพลาดที่ได้
  I = I + error; //ส่วนสะสมของความผิดพลาด (I) ถูกเพิ่มขึ้นโดยเรียบเรียงความผิดพลาดในแต่ละรอบ
  D = (error - lastError); //ส่วนปริพันธ์ของความผิดพลาด (D) คำนวณจากความแตกต่างระหว่างความผิดพลาดปัจจุบันและความผิดพลาดก่อนหน้า (lastError)
  outputpid = P * Kp + Ki * I + Kd * D;//คำนวณค่าสัญญาณควบคุม PID (outputpid) โดยใช้สมการ PID ดังกล่าว
  lastError = error;//อัปเดตค่าความผิดพลาดก่อนหน้าเพื่อใช้ในการคำนวณส่วนปริพันธ์ของความผิดพลาด (D) ในรอบถัดไป
  float motorL = constrain(motorspeed + outputpid, -motorspeed, motorspeed);
  //float motorL = constrain(motorspeed + outputpid, -motorspeed, motorspeed);: คำนวณความเร็วของมอเตอร์ด้านซ้าย (motorL) 
  //โดยเพิ่มหรือลดความเร็วที่ได้จากค่าสัญญาณควบคุม PID และใช้ constrain เพื่อรับประกันว่าความเร็วอยู่ในช่วงที่กำหนด
  float motorR = constrain(motorspeed - outputpid, -motorspeed, motorspeed);
  motor(1, motorL);//motor(1, motorL); และ motor(2, motorR);: เรียกฟังก์ชัน motor() เพื่อควบคุมมอเตอร์ด้านซ้ายและด้านขวาโดยให้ความเร็วที่คำนวณไว้
  motor(2, motorR);
  delay(1);
}
/* *********************************************************************************************************** */
unsigned long Timesince = 0;  // ประกาศตัวแปร Timesince แบบ unsigned long และกำหนดค่าเริ่มต้นเป็น 0
void tracktime(int timer) {   // สร้างฟังก์ชัน tracktime ที่รับพารามิเตอร์ timer
  Timesince = millis();       // millis() ใช้ในการดูเวลาปัจจุบันในมิลลิวินาที (1/1000 วินาที) ของ Arduino
  while ((millis() - Timesince) < timer) { // timer คือระยะเวลาที่คุณต้องการให้ผ่านไปจนกว่าจะออกจากลูป while.
    // รอจนกว่า (เวลาปัจจุบัน - เวลาตั้งต้น) จะน้อยกว่าค่า timer
    // คำสั่งที่ต้องการให้ทำจะถูกทำซ้ำในลูปนี้ในระหว่างรอ
    track5sensor();
  }
  // หลังจากออกจากลูป while, แสดงว่าเวลา (millis() - Timesince) มีค่ามากกว่าหรือเท่ากับ timer
  // คุณสามารถทำคำสั่งที่ต้องการหลังจากการรอที่กำหนดในลูป while ได้ทันที
}
/* *********************************************************************************************************** */
void trackstop() {                               //ฟังก์ชันวิ่งแทร็กเส้นจนกว่าจะเจอเส้นตัดสีดำแล้วหยุด
  while (true) {                                 //วนซ้ำจนกว่าเงื่อนไขจะเป็นจริง
    if (ADC(0) < reff[0] && ADC(4) < reff[4]) {  //ถ้่า 0 และ 4 เจอดำพร้อมกัน ให้มอเตอร์ทั้งหมดหยุดหมุน 0.2วินาทีแล้วหลุดออกจาก While Loop ด้วยคำสั่ง Break;
      motorBreak(0);
      delay(200);
      break;
    } else  //ถ้าเงื่อนไขยังไม่เป็นจริงให้วิ่งแทร็กเส้น
    {
      track5sensor();
    }
  }
}
/* *********************************************************************************************************** */
void pidstop() {                               //ฟังก์ชันวิ่งแทร็กPIDเส้นจนกว่าจะเจอเส้นตัดสีดำแล้วหยุด
  while (true) {                                 //วนซ้ำจนกว่าเงื่อนไขจะเป็นจริง
    if (ADC(0) < reff[0] && ADC(4) < reff[4]) {  //ถ้่า 0 และ 4 เจอดำพร้อมกัน ให้มอเตอร์ทั้งหมดหยุดหมุน 0.2วินาทีแล้วหลุดออกจาก While Loop ด้วยคำสั่ง Break;
      motorBreak(0);
      delay(200);
      break;
    } else  //ถ้าเงื่อนไขยังไม่เป็นจริงให้วิ่งแทร็กเส้นPID
    {
      pidcontrolmotor();
    }
  }
}
/* *********************************************************************************************************** */
void track5sensor() {      //ฟังก์ชันเดินตามเส้นสำหรับ 5 sensor
  if (ADC(0) < reff[0]) {  //ถ้า s0 เจอดำ หมุนซ้าย
    motor(1, -20);
    motor(2, 20);
  } else if (ADC(1) < reff[1]) {  //ถ้า s1 เจอดำ หมุนซ้าย
    motor(1, 0);
    motor(2, 20);
  } else if (ADC(2) < reff[2]) {  //ถ้า s2 เจอดำ ตรงไป
    motor(1, 20);
    motor(2, 20);
  } else if (ADC(3) < reff[3]) {  //ถ้า s3 เจอดำ หมุนขวา
    motor(1, 20);
    motor(2, 0);
  } else if (ADC(4) < reff[4]) {  //ถ้า s4 เจอดำ หมุนขวา
    motor(1, 20);
    motor(2, -20);
  }
}
/* *********************************************************************************************************** */
void track2sensor() {      //ฟังก์ชันสำหรับเดินตามเส้น2เซนเซอร์
 // ตรวจสอบสภาพเส้นทาง
  if (ADC(0) > reff[0] && ADC[4] > reff[4]) {
    // สองเซนเซอร์อยู่บนพื้นขาว (เส้นดำ)
    // เดินตรงไปข้างหน้า
    motor(1,20);
    motor(2,20);
  } else if (ADC(0) < reff[0]) {
    // เซนเซอร์ด้านซ้ายอยู่บนเส้น (ดำ)
    // หมุนไปทางซ้าย
    motor(1,-20);
    motor(2,20);
  } else if (ADC[4] < reff[4]) {
    // เซนเซอร์ด้านขวาอยู่บนเส้น (ดำ)
    // หมุนไปทางขวา
    motor(1,20);
    motor(2,-20);
  } else {
    // ไม่มีเงื่อนไขถูกต้องที่เซนเซอร์ได้รับสัญญาณ (อาจหมายถึงหุ่นยนต์หลงทาง)
    // หยุดหุ่นยนต์
    motor(1,0);
    motor(2,0);
  } 
} 
/* *********************************************************************************************************** */
void catch_the_can() {  //ฟังก์ชันสำหรับหนีบมือจับเข้า
  motorBreak(0);
  delay(50);
  servoRun(1, Servo_degreeA1);
  delay(1000);
  motorBreak(0);
  delay(50);
}
/* *********************************************************************************************************** */
void release_can() {  //ฟังก์ชันสำหรับกางมือจับออก
  motorBreak(0);
  delay(50);
  servoRun(1, Servo_degreeA2);
  delay(1000);
  motorBreak(0);
  delay(50);
}
/* *********************************************************************************************************** */
void put_hand_up() {  //ฟังก์ชันสำหรับยกแขนขึ้น
  motorBreak(0);
  delay(50);
  servoRun(1, Servo_degreeB1);
  delay(1000);
  motorBreak(0);
  delay(50);
}
/* *********************************************************************************************************** */
void put_hand_down() {  //ฟังก์ชันสำหรับกางแขนออก
  motorBreak(0);
  delay(50);
  servoRun(1, Servo_degreeB2);
  delay(1000);
  motorBreak(0);
  delay(50);
}
/* *********************************************************************************************************** */
void setup() {       //ส่วนการทำงานของโปรแกรมทำงานรอบเดียว
  puppybot_setup();  // ฟังก์ชันที่ทำงานเพื่อตั้งค่าเริ่มต้นของระบบหุ่นยนต์หรืออุปกรณ์ "puppybot" ในโปรแกรม Arduino.
  wait_SW1();        //รอให้ผู้ใช้กดสวิตช์ SW1
  pidstop();       //ฟังก์ชันวิ่งแทร็กเส้นPIDและเมื่อเจอเส้นตัดจะทำการควบคุมการหยุดการทำงานหรือการเคลื่อนไหวของระบบหุ่นยนต์ให้หยุด
}
/* *********************************************************************************************************** */
void loop() {  //ส่วนการทำงานของโปรแกรมทำงานวนซ้ำ

}
/* *********************************************************************************************************** */